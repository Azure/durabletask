trigger:
- main

pr: none

pool:
  name: '1ES-Hosted-DurableTaskFramework'
  demands:
    - ImageOverride -equals MMS2022TLS

variables:

  - name: VersionSuffix
    # The `Build.Reason` env var gets populated with `IndividualCI` on an automatic run of the CI,
    # such as when a commit is made to `main`. If the CI is manually run, it will get populated with
    # "Manual". For more details on these `Build.X` vars, see: https://learn.microsoft.com/en-us/azure/devops/pipelines/build/variables?view=azure-devops&tabs=yaml#build-variables-devops-services
    ${{ if eq(variables['Build.Reason'], 'IndividualCI') }}:
      # The `Build.BuildNumber` env var is an automatically-generated "build ID"
      # for any given ADO run. It is usually the date format yyddmm.<counter> where
      # `yyddmm` is a date formatter, and <counter> is a daily counter in case of multiple
      # builds on the same date.
      value: 'ci.$(Build.BuildNumber)'
    ${{ else }}:
      value: ''

steps:
# Start by restoring all the dependencies. This needs to be its own task
# from what I can tell. We specifically only target DurableTask.AzureStorage
# and its direct dependencies.
- task: DotNetCoreCLI@2
  displayName: 'Restore nuget dependencies'
  inputs:
    command: restore
    verbosityRestore: Minimal
    projects: |
      src/DurableTask.AzureStorage/DurableTask.AzureStorage.sln
      src/DurableTask.Emulator/DurableTask.Emulator.csproj
      src/DurableTask.ServiceBus/DurableTask.ServiceBus.csproj
      src/DurableTask.AzureServiceFabric/DurableTask.AzureServiceFabric.csproj
      src/DurableTask.ApplicationInsights/DurableTask.ApplicationInsights.csproj

# Build the filtered solution in release mode, specifying the continuous integration flag.
- task: VSBuild@1
  displayName: 'Build (AzureStorage)'
  inputs:
    solution: 'src/DurableTask.AzureStorage/DurableTask.AzureStorage.sln'
    vsVersion: '16.0'
    logFileVerbosity: minimal
    configuration: Release
    msbuildArgs: /p:FileVersionRevision=$(Build.BuildId) /p:ContinuousIntegrationBuild=true

- task: VSBuild@1
  displayName: 'Build (ApplicationInsights)'
  inputs:
    solution: 'src/DurableTask.ApplicationInsights/DurableTask.ApplicationInsights.csproj'
    vsVersion: '16.0'
    logFileVerbosity: minimal
    configuration: Release
    msbuildArgs: /p:FileVersionRevision=$(Build.BuildId) /p:ContinuousIntegrationBuild=true

- task: VSBuild@1
  displayName: 'Build (Emulator)'
  inputs:
    solution: 'src/DurableTask.Emulator/DurableTask.Emulator.csproj'
    vsVersion: '16.0'
    logFileVerbosity: minimal
    configuration: Release
    msbuildArgs: /p:FileVersionRevision=$(Build.BuildId) /p:ContinuousIntegrationBuild=true

- task: VSBuild@1
  displayName: 'Build (ServiceBus)'
  inputs:
    solution: 'src/DurableTask.ServiceBus/DurableTask.ServiceBus.csproj'
    vsVersion: '16.0'
    logFileVerbosity: minimal
    configuration: Release
    msbuildArgs: /p:FileVersionRevision=$(Build.BuildId) /p:ContinuousIntegrationBuild=true

- task: VSBuild@1
  displayName: 'Build (AzureServiceFabric)'
  inputs:
    solution: 'src/DurableTask.AzureServiceFabric/DurableTask.AzureServiceFabric.csproj'
    vsVersion: '16.0'
    logFileVerbosity: minimal
    configuration: Release
    platform: x64
    msbuildArgs: /p:FileVersionRevision=$(Build.BuildId) /p:ContinuousIntegrationBuild=true

- task: UseDotNet@2
  displayName: 'Use the .NET Core 2.1 SDK (required for build signing)'
  inputs:
    packageType: 'sdk'
    version: '2.1.x'

# Manifest Generator Task
- task: AzureArtifacts.manifest-generator-task.manifest-generator-task.ManifestGeneratorTask@0
  displayName: 'Manifest Generator '
  inputs:
    BuildDropPath: '$(System.DefaultWorkingDirectory)'

# Authenticode sign all the DLLs with the Microsoft certificate.
# This appears to be an in-place signing job, which is convenient.
- task: SFP.build-tasks.custom-build-task-1.EsrpCodeSigning@1
  displayName: 'ESRP CodeSigning: Authenticode'
  inputs:
    ConnectedServiceName: 'ESRP Service'
    FolderPath: 'src'
    Pattern: 'DurableTask.*.dll'
    signConfigType: inlineSignParams
    inlineOperation: |
     [    
        {
            "KeyCode": "CP-230012",
            "OperationCode": "SigntoolSign",
            "Parameters": {
                "OpusName": "Microsoft",
                "OpusInfo": "http://www.microsoft.com",
                "FileDigest": "/fd \"SHA256\"",
                "PageHash": "/NPH",
                "TimeStamp": "/tr \"http://rfc3161.gtm.corp.microsoft.com/TSS/HttpTspServer\" /td sha256"
            },
            "ToolName": "sign",
            "ToolVersion": "1.0"
          },
          {
              "KeyCode": "CP-230012",
              "OperationCode": "SigntoolVerify",
              "Parameters": {},
              "ToolName": "sign",
              "ToolVersion": "1.0"
          }
      ]

# Packaging needs to be a separate step from build.
# This will automatically pick up the signed DLLs.

- task: DotNetCoreCLI@2
  displayName: Generate nuget packages
  inputs:
    command: pack
    verbosityPack: Minimal
    configuration: Release
    nobuild: true
    packDirectory: $(build.artifactStagingDirectory)
    packagesToPack: 'src/DurableTask.AzureStorage/DurableTask.AzureStorage.sln'

- task: DotNetCoreCLI@2
  displayName: Generate nuget packages
  inputs:
    command: pack
    verbosityPack: Minimal
    configuration: Release
    nobuild: true
    packDirectory: $(build.artifactStagingDirectory)
    packagesToPack: 'src/DurableTask.ApplicationInsights/DurableTask.ApplicationInsights.csproj'

- task: DotNetCoreCLI@2
  displayName: Generate nuget packages
  inputs:
    command: pack
    verbosityPack: Minimal
    configuration: Release
    nobuild: true
    packDirectory: $(build.artifactStagingDirectory)
    packagesToPack: 'src/DurableTask.Emulator/DurableTask.Emulator.csproj'

- task: DotNetCoreCLI@2
  displayName: Generate nuget packages
  inputs:
    command: pack
    verbosityPack: Minimal
    configuration: Release
    nobuild: true
    packDirectory: $(build.artifactStagingDirectory)
    packagesToPack: 'src/DurableTask.ServiceBus/DurableTask.ServiceBus.csproj'

- task: DotNetCoreCLI@2
  displayName: Generate nuget packages
  inputs:
    command: pack
    verbosityPack: Minimal
    configuration: Release
    nobuild: true
    packDirectory: $(build.artifactStagingDirectory)
    packagesToPack: 'src/DurableTask.AzureServiceFabric/DurableTask.AzureServiceFabric.csproj'
    buildProperties: 'Platform=x64'

# Digitally sign all the nuget packages with the Microsoft certificate.
# This appears to be an in-place signing job, which is convenient.
- task: SFP.build-tasks.custom-build-task-1.EsrpCodeSigning@1
  displayName: 'ESRP CodeSigning: Nupkg'
  inputs:
    ConnectedServiceName: 'ESRP Service'
    FolderPath: $(build.artifactStagingDirectory)
    Pattern: '*.nupkg'
    signConfigType: inlineSignParams
    inlineOperation: |
     [    
        {
            "KeyCode": "CP-401405",
            "OperationCode": "NuGetSign",
            "Parameters": {},
            "ToolName": "sign",
            "ToolVersion": "1.0"
        },
        {
            "KeyCode": "CP-401405",
            "OperationCode": "NuGetVerify",
            "Parameters": {},
            "ToolName": "sign",
            "ToolVersion": "1.0"
        }
     ]

# Make the nuget packages available for download in the ADO portal UI
- publish: $(build.artifactStagingDirectory)
  displayName: 'Publish nuget packages to Artifacts'
  artifact: PackageOutput

# Next, push the payload to the ADO feed
- task: NuGetToolInstaller@1
  displayName: 'Use NuGet '

- task: NuGetCommand@2
  displayName: 'Push to durabletask ADO feed'
  inputs:
    command: push
    feedsToUse: config
    packagesToPush: '$(build.artifactStagingDirectory)/*.nupkg'
    publishVstsFeed: '734e7913-2fab-4624-a174-bc57fe96f95d/d55248c1-5b53-411f-bfe7-73efc9e540d1'
    allowPackageConflicts: true
